<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QP/C: ARM Cortex-M</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="ql-preview.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="ql-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectlogo">
    <a href="https://www.state-machine.com" title="Quantum Leaps"><img alt="Logo" src="logo_ql.png"/></a>
  </div>
   <div id="projectname">
    QP/C
    &nbsp;<span id="projectnumber">7.3.4</span>
   </div>
   <div id="projectbrief">Real-Time Embedded Framework</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('arm-cm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ARM Cortex-M</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section describes the QP/C ports to the ARM Cortex-M processor family (Cortex M0/M0+/M3/M4/M7/M33). Three main implementation options are covered: the <a class="el" href="arm-cm_qv.html">cooperative, priority-based QV kernel</a>, the <a class="el" href="arm-cm_qk.html">preemptive, run-to-completion QK kernel</a>, and the <a class="el" href="arm-cm_qxk.html">preemptive, dual-mode blocking QXK kernel</a>. Additionally, the use of the VFP (floating point coprocessor) in the M4F/M7/M33 CPUs is explained as well. This document assumes QP/C version 7.x or higher.</p>
<dl class="section note"><dt>Note</dt><dd>To focus the discussion, this section references the <b>GNU-ARM toolchain</b>, the <a href="bd_EK-TM4C123GXL.jpg" class="preview board" title="EK-TM4C123GXL">EK-TM4C123GXL</a> (ARM Cortex-M4F) and the Eclipse-based IDE (CCS from Texas Instruments). However, the general implementation strategy applies equally to all toolchains for ARM Cortex-M, such as <b>ARM-KEIL</b>, <b>IAR EWARM</b>, <b>GNU-ARM</b> and <b>TI-ARM</b>, which are all supported as well. The QP code downloads contain also examples for other boards, such as STM32 Nucleo, NXP mbed-1768, SilLabs Gecko and others.</dd></dl>
<h1><a class="anchor" id="arm-cm_files"></a>
Directories and Files</h1>
<p>The QP ports to ARM Cortex-M are available in the standard QP/C distribution. Specifically, the ARM Cortex-M ports are placed in the following directories:</p>
<p><br  />
 </p><div class="fragment"><div class="line">qp/ports/arm-cm     <span class="comment">// QP ports to ARM Cortex-M</span></div>
<div class="line">+---qk              <span class="comment">// ports to QK preemptive kernel</span></div>
<div class="line">|   +---armclang    <span class="comment">// ports for ARM-CLANG (LLVM)</span></div>
<div class="line">|   |       qp_port.h   <span class="comment">// QP port</span></div>
<div class="line">|   |       qs_port.h   <span class="comment">// QS port</span></div>
<div class="line">|   |       qk_port.c   <span class="comment">// QK port implementation</span></div>
<div class="line">|   +---gnu         <span class="comment">// ports for GNU-ARM</span></div>
<div class="line">|   |       ~ ~ ~</div>
<div class="line">|   +---iar         <span class="comment">// ports for IAR EWARM</span></div>
<div class="line">|   |       ~ ~ ~</div>
<div class="line">+---qv              <span class="comment">// ports to QV cooperative kernel</span></div>
<div class="line">|   +---armclang    <span class="comment">// ports for ARM-CLANG (LLVM)</span></div>
<div class="line">|   |       qp_port.h   <span class="comment">// QP port</span></div>
<div class="line">|   |       qs_port.h   <span class="comment">// QS port</span></div>
<div class="line">|   |       qv_port.c   <span class="comment">// QV port implementation</span></div>
<div class="line">|   +---gnu         <span class="comment">// ports for GNU-ARM</span></div>
<div class="line">|   |       ~ ~ ~</div>
<div class="line">|   +---iar         <span class="comment">// ports for IAR EWARM</span></div>
<div class="line">|   |       ~ ~ ~</div>
<div class="line">+---qxk             <span class="comment">// ports to QXK dual-mode kernel</span></div>
<div class="line">|   +---armclang    <span class="comment">// ports for ARM-CLANG (LLVM)</span></div>
<div class="line">|   |       qp_port.h   <span class="comment">// QP port</span></div>
<div class="line">|   |       qs_port.h   <span class="comment">// QS port</span></div>
<div class="line">|   |       qxk_port.c  <span class="comment">// QXK port implementation</span></div>
<div class="line">|   +---gnu         <span class="comment">// ports for GNU-ARM</span></div>
<div class="line">|   |       ~ ~ ~</div>
<div class="line">|   +---iar         <span class="comment">// ports for IAR EWARM</span></div>
<div class="line">|   |       ~ ~ ~</div>
</div><!-- fragment --><h1><a class="anchor" id="arm-cm_int"></a>
Interrupts in the QP/C Ports to ARM Cortex-M</h1>
<p>The QP/C real-time framework, like any real-time kernel, needs to disable interrupts in order to access critical sections of code and re-enable interrupts when done. This section describes the general policy used in the ARM Cortex-M ports of all built-in real time kernels in QP/C, such as <a class="el" href="struct_q_v.html" title="QV non-preemptive, cooperative kernel (QV namespace emulated as a &quot;class&quot; in C)">QV</a>, <a class="el" href="struct_q_k.html" title="QK preemptive non-blocking kernel (QK namespace emulated as a &quot;class&quot; in C)">QK</a>, and <a class="el" href="struct_q_x_k.html" title="QXK dual-mode kernel (QXK namespace emulated as a &quot;class&quot; in C)">QXK</a>.</p>
<p><b>"Kernel-Aware" and "Kernel-Unaware" Interrupts</b><br  />
 The QP/C ports to ARMv7M or higher architectures <b>never completely disables interrupts</b>, even inside the critical sections. On ARMv7M or higher architectures, the QP/C port disables interrupts <b>selectively</b> using the BASEPRI register. This policy divides interrupts into "kernel-unaware" interrupts, which are never disabled, and "kernel-aware" interrupts, which are disabled in the QP/C critical sections.</p>
<dl class="section note"><dt>Note</dt><dd>The BASEPRI register is not implemented in the ARMv6-M architecture (Cortex-M0/M0+), so Cortex-M0/M0+ CPUs need to use the PRIMASK register to disable interrupts globally. In other words, in the QP/C ports to Cortex-M0/M0+, all interrupts are "kernel-aware".</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Only "kernel-aware" interrupts are allowed to call QP/C services. "Kernel-unaware" interrupts are <b>not</b> allowed to call any QP/C services and they can communicate with QP/C only by triggering a "kernel-aware" interrupt (which can post or publish events).</dd></dl>
<p>As illustrated in the figures below, the number of interrupt priority bits actually available is implementation dependent, meaning that the various ARM Cortex-M silicon vendors can provide different number of priority bits, varying from just 3 bits (which is the minimum for ARMv7-M architecture) up to 8 bits. For example, the TI Tiva-C microcontrollers implement only 3 priority bits (see figure below).</p>
<div class="image">
<img src="arm-cm_int3bit.png" alt=""/>
</div>
  <div class="caption"><center><em>Kernel-aware and Kernel-unaware interrupts with 3 priority bits)</em></center></div><p>On the other hand, the STM32 MCUs implement 4 priority bits (see figure below). The CMSIS standard provides the macro <b>NVIC_PRIO_BITS</b>, which specifies the number of NVIC priority bits defined in a given ARM Cortex-M implementation.</p>
<div class="image">
<img src="arm-cm_int4bit.png" alt=""/>
</div>
  <div class="caption"><center><em>Kernel-aware and Kernel-unaware interrupts with 4 priority bits](arm-cm_int4bit.png</em></center></div><p>Another important fact to note is that the ARM Cortex-M core stores the interrupt priority values in the <em>most significant bits</em> of its eight bit interrupt priority registers inside the NVIC (Nested Vectored Interrupt Controller). For example, if an implementation of a ARM Cortex-M microcontroller only implements three priority bits, then these three bits are shifted to occupy bits five, six and seven respectively. The unimplemented bits can be written as zero or one and always read as zero.</p>
<p>And finally, the NVIC uses an inverted priority numbering scheme for interrupts, in which priority zero (0) is the highest possible priority (highest urgency) and larger priority numbers denote actually lower-priority interrupts. So for example, interrupt of priority 2 can preempt an interrupt with priority 3, but interrupt of priority 3 cannot preempt interrupt of priority 3. The default value of priority of all interrupts out of reset is zero (0).</p>
<dl class="section note"><dt>Note</dt><dd>Starting with QP/C 5.9.x, the <a class="el" href="qutest_8c.html#adac7eccb860d910c4e446d3143798bba">QF_init()</a> call sets interrupt priority of all IRQs to the "kernel aware" value <b>QF_BASEPRI</b>. Still, it is highly recommended to set the priority of all interrupts used by an application <b>explicitly</b>, preferably in the <code>QF_onStartup()</code>.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Some 3rd-party libraries (e.g., STM32Cube) change the interrupt priorities and sometimes priority grouping internally and unexpectedly, so care must be taken to change the priorities back to the appropriate values right before running the application.</dd></dl>
<p>The CMSIS provides the function <code>NVIC_SetPriority()</code> which you should use to set priority of every interrupt.</p>
<dl class="section note"><dt>Note</dt><dd>The priority scheme passed to <code>NVIC_SetPriority()</code> is different again than the values stored in the NVIC registers, as shown in the figures above as "CMSIS priorities"</dd></dl>
<p><b>Assigning Interrupt Priorities</b><br  />
 The <a class="el" href="exa.html">example projects</a> included in the QP/C distribution the recommended way of assigning interrupt priorities in your applications. The initialization consist of two steps: (1) you enumerate the "kernel-unaware" and "kernel-aware" interrupt priorities, and (2) you assign the priorities by calling the <code>NVIC_SetPriority()</code> CMSIS function. The following snippet of code illustrates these steps with the explanation section following immediately after the code.</p>
<div class="caption"><center><em>Listing: Assigning the interrupt priorities (see file bsp.c in the example projects)</em></center></div> <div class="fragment"><div class="line"><span class="comment">    /*!!!!!!!!!!!!!!!!!!!!!!!!!!!!! CAUTION !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></div>
<div class="line"><span class="comment">      Assign a priority to EVERY ISR explicitly by calling NVIC_SetPriority().</span></div>
<div class="line"><span class="comment">      DO NOT LEAVE THE ISR PRIORITIES AT THE DEFAULT VALUE!</span></div>
<div class="line"><span class="comment">     /</span></div>
<div class="line"><span class="comment">[1] enum KernelUnawareISRs {  /* see NOTE0 */</span></div>
<div class="line">        <span class="comment">/* ... */</span></div>
<div class="line">[2]     MAX_KERNEL_UNAWARE_CMSIS_PRI <span class="comment">/* keep always last */</span></div>
<div class="line">    };</div>
<div class="line">    <span class="comment">/* &quot;kernel-unaware&quot; interrupts can&#39;t overlap &quot;kernel-aware&quot; interrupts */</span></div>
<div class="line">[3] <a class="code hl_define" href="qpc_8h.html#a753a7ea8d4943b60d5d96a843a535288">Q_ASSERT_COMPILE</a>(MAX_KERNEL_UNAWARE_CMSIS_PRI &lt;= QF_AWARE_ISR_CMSIS_PRI);</div>
<div class="line"> </div>
<div class="line">[4] <span class="keyword">enum</span> KernelAwareISRs {</div>
<div class="line">[5]     GPIOPORTA_PRI = QF_AWARE_ISR_CMSIS_PRI, <span class="comment">/* see NOTE00 */</span></div>
<div class="line">        SYSTICK_PRIO,</div>
<div class="line">        <span class="comment">/* ... */</span></div>
<div class="line">[6]     MAX_KERNEL_AWARE_CMSIS_PRI  <span class="comment">/* keep always last */</span></div>
<div class="line">    };</div>
<div class="line">    <span class="comment">/* &quot;kernel-aware&quot; interrupts should not overlap the PendSV priority */</span></div>
<div class="line">[7] <a class="code hl_define" href="qpc_8h.html#a753a7ea8d4943b60d5d96a843a535288">Q_ASSERT_COMPILE</a>(MAX_KERNEL_AWARE_CMSIS_PRI &lt;= (0xFF&gt;&gt;(8-__NVIC_PRIO_BITS)));</div>
<div class="line"> </div>
<div class="line">    ~ ~ ~</div>
<div class="line"> </div>
<div class="line">[8] <span class="keywordtype">void</span> QF_onStartup(<span class="keywordtype">void</span>) {</div>
<div class="line">        <span class="comment">/* set up the SysTick timer to fire at BSP_TICKS_PER_SEC rate */</span></div>
<div class="line">        SysTick_Config(ROM_SysCtlClockGet() / BSP_TICKS_PER_SEC);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* assign all priority bits for preemption-prio. and none to sub-prio. */</span></div>
<div class="line">[9]     NVIC_SetPriorityGrouping(0U);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">/* set priorities of ALL ISRs used in the system, see NOTE00</span></div>
<div class="line"><span class="comment">         </span></div>
<div class="line"><span class="comment">          !!!!!!!!!!!!!!!!!!!!!!!!!!!! CAUTION !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></div>
<div class="line"><span class="comment">          Assign a priority to EVERY ISR explicitly by calling NVIC_SetPriority().</span></div>
<div class="line"><span class="comment">          DO NOT LEAVE THE ISR PRIORITIES AT THE DEFAULT VALUE!</span></div>
<div class="line"><span class="comment">         /</span></div>
<div class="line"><span class="comment">[10]    NVIC_SetPriority(SysTick_IRQn,   SYSTICK_PRIO);</span></div>
<div class="line"><span class="comment">[11]    NVIC_SetPriority(GPIOPortA_IRQn, GPIOPORTA_PRIO);</span></div>
<div class="line"><span class="comment">        ~ ~ ~</span></div>
<div class="line"><span class="comment">        /* enable IRQs... */</span></div>
<div class="line">[12]    NVIC_EnableIRQ(GPIOPortA_IRQn);</div>
<div class="line">    }</div>
<div class="ttc" id="aqpc_8h_html_a753a7ea8d4943b60d5d96a843a535288"><div class="ttname"><a href="qpc_8h.html#a753a7ea8d4943b60d5d96a843a535288">Q_ASSERT_COMPILE</a></div><div class="ttdeci">#define Q_ASSERT_COMPILE(expr_)</div><div class="ttdef"><b>Definition</b> <a href="qpc_8h_source.html#l00114">qpc.h:114</a></div></div>
</div><!-- fragment --><p><code>[1]</code> The enumeration <code>KernelUnawareISRs</code> lists the priority numbers for the "kernel-unaware" interrupts. These priorities start with zero (highest possible). The priorities are suitable as the argument for the <code>NVC_SetPriority()</code> CMSIS function.</p>
<dl class="section note"><dt>Note</dt><dd>The NVIC allows you to assign the same priority level to multiple interrupts, so you can have more ISRs than priority levels running as "kernel-unaware" or "kernel-aware" interrupts.</dd></dl>
<p><code>[2]</code> The last value in the enumeration MAX_KERNEL_UNAWARE_CMSIS_PRI keeps track of the maximum priority used for a "kernel-unaware" interrupt.</p>
<p><code>[3]</code> The compile-time assertion ensures that the "kernel-unaware" interrupt priorities do not overlap the "kernel-aware" interrupts, which start at QF_AWARE_ISR_CMSIS_PRI.</p>
<p><code>[4]</code> The enumeration KernelAwareISRs lists the priority numbers for the "kernel-aware" interrupts.</p>
<p><code>[5]</code> The "kernel-aware" interrupt priorities start with the QF_AWARE_ISR_CMSIS_PRI offset, which is provided in the <a class="el" href="qp__port_8h.html" title="Sample QP/C port.">qp_port.h</a> header file.</p>
<p><code>[6]</code> The last value in the enumeration MAX_KERNEL_AWARE_CMSIS_PRI keeps track of the maximum priority used for a "kernel-aware" interrupt.</p>
<p><code>[7]</code> The compile-time assertion ensures that the "kernel-aware" interrupt priorities do not overlap the lowest priority level reserved for the PendSV exception.</p>
<p><code>[8]</code> The QF_onStartup() callback function is where you set up the interrupts.</p>
<p><code>[9]</code> This call to the CMIS function <code>NVIC_SetPriorityGrouping()</code> assigns all the priority bits to be preempt priority bits, leaving no priority bits as subpriority bits to preserve the direct relationship between the interrupt priorities and the ISR preemption rules. This is the default configuration out of reset for the ARM Cortex-M3/M4 cores, but it can be changed by some vendor-supplied startup code. To avoid any surprises, the call to <code>NVIC_SetPriorityGrouping(0U)</code> is recommended.</p>
<p><code>[10]</code> The interrupt priories fall all interrupts ("kernel-unaware" and "kernel-aware" alike) are set explicitly by calls to the CMSIS function <code>NVIC_SetPriority()</code>.</p>
<p><code>[11]</code> All used IRQ interrupts need to be explicitly enabled by calling the CMSIS function.</p>
<p><b>Interrupts and the FPU (ARMv7M or higher architectures)</b><br  />
 The QP/C ports described in this section support also the ARMv7M or higher architectures. Compared to all other members of the Cortex-M family, these cores includes the single precision variant of the ARMv7-M Floating-Point Unit (Fpv4-SP). The hardware FPU implementation adds an extra floating-point register bank consisting of S0-S31 and some other FPU registers. This FPU register set represents additional context that need to be preserved across interrupts and thread switching (e.g., in the preemptive <a class="el" href="struct_q_k.html" title="QK preemptive non-blocking kernel (QK namespace emulated as a &quot;class&quot; in C)">QK</a> kernel).</p>
<p>The ARM VFP has a very interesting feature called <b>lazy stacking</b> [<a class="el" href="arm-cm.html#ARM-AN298">ARM-AN298</a>]. This feature avoids an increase of interrupt latency by skipping the stacking of floating-point registers, if not required, that is:</p>
<ul>
<li>if the interrupt handler does not use the FPU, or</li>
<li>if the interrupted program does not use the FPU.</li>
</ul>
<p>If the interrupt handler has to use the FPU and the interrupted context has also previously used by the FPU, then the stacking of floating-point registers takes place at the point in the program where the interrupt handler first uses the FPU. The lazy stacking feature is programmable and by default it is turned ON.</p>
<dl class="section note"><dt>Note</dt><dd>All built-in kernels in QP/C are designed to take advantage of the lazy stacking feature [<a class="el" href="arm-cm.html#ARM-AN298">ARM-AN298</a>].</dd></dl>
<h1><a class="anchor" id="arm-cm_ref"></a>
References</h1>
<p><a class="anchor" id="ARM-AN298"></a></p><ul>
<li><b>[ARM AN298]</b> <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dai0298a/DAI0298A_cortex_m4f_lazy_stacking_and_context_switching.pdf" target="_blank" class="extern">ARM Application Note 298 "Cortex-M4(F) Lazy Stacking and Context Switching", ARM 2012</a></li>
</ul>
<p><a class="anchor" id="ARM-EPM-064408"></a></p><ul>
<li><b>[ARM-EPM-064408]</b> <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.epm064408/index.html" target="_blank" class="extern">"ARM Processor Cortex-M7 (AT610) and Cortex-M7 with FPU (AT611) Software Developers Errata Notice"</a></li>
</ul>
<p><a class="anchor" id="Reminder"></a></p><ul>
<li><b>[Reminder]</b> <a href="https://www.state-machine.com/doc/Pattern_Reminder.pdf" target="_blank" class="extern">"Reminder State Pattern"</a></li>
</ul>
<p><span class="next_button"><a class="el" href="arm-cm_qv.html">Cooperative QV Kernel</a></span>  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="ports.html">Ports</a></li><li class="navelem"><a class="el" href="ports_native.html">Native Ports (Built-in Kernels)</a></li>
    <li class="footer">
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
<hr class="footer"/><address class="footer"><small>
<a title="Quantum Leaps: Modern Embedded Software" href="https://www.state-machine.com">&copy; 2005-2024 Quantum Leaps</a> &nbsp;|&nbsp; <a title="help" href="help.html">Using Online Help</a> &nbsp;|&nbsp; <b>QP/C 7.3.4</b> &nbsp;|&nbsp; Updated on Thu Mar 21 2024
</small></address>
    </li>
  </ul>
</div>
</body>
</html>
